import axios from 'axios';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Platform } from 'react-native';

// En d√©veloppement, utilisez localhost pour le web et 10.0.2.2 pour Android (√©mulateur)
const BASE_URL = Platform.select({
  web: 'http://localhost:8000',
  android: 'http://10.0.2.2:8000', // Pour l'√©mulateur Android
  ios: 'http://192.168.1.98:8000',    // Pour iOS
  default: 'http://localhost:8000'
});

const api = axios.create({
  baseURL: BASE_URL,
  timeout: 300000, // 5 minutes de timeout par d√©faut
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
  },
  withCredentials: false,
});

// Configuration des intercepteurs
api.interceptors.request.use(
  async (config) => {
    // Pour toutes les requ√™tes
    const token = await AsyncStorage.getItem('userToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }

    // Log de la configuration finale
    console.log('üîµ Configuration de la requ√™te:', {
      url: `${config.baseURL}${config.url}`,
      method: config.method,
      headers: config.headers,
      data: config.data ? JSON.stringify(config.data).substring(0, 500) : undefined
    });

    return config;
  },
  (error) => {
    console.error('‚ùå Erreur de configuration:', error);
    return Promise.reject(error);
  }
);

// Intercepteur de r√©ponse pour g√©rer les erreurs
api.interceptors.response.use(
  (response) => {
    console.log('‚úÖ R√©ponse re√ßue:', {
      status: response.status,
      headers: response.headers,
      data: response.data
    });
    return response;
  },
  (error) => {
    if (error.response) {
      console.error('‚ùå Erreur serveur:', {
        status: error.response.status,
        data: error.response.data,
        headers: error.response.headers
      });
    } else if (error.request) {
      console.error('‚ùå Erreur r√©seau:', {
        request: error.request,
        config: error.config
      });
    } else {
      console.error('‚ùå Erreur de configuration:', error.message);
    }
    return Promise.reject(error);
  }
);

export const login = async (username, password) => {
  try {
    console.log('üîµ Tentative de connexion avec:', { username });
    
    const formData = new URLSearchParams();
    formData.append('username', username);
    formData.append('password', password);
    formData.append('grant_type', 'password');

    console.log('üîµ Donn√©es de connexion pr√©par√©es:', formData.toString());

    const response = await api.post('/auth', formData.toString(), {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json'
      },
    });

    console.log('‚úÖ R√©ponse compl√®te:', response);
    console.log('‚úÖ Donn√©es de r√©ponse:', response.data);

    if (!response.data) {
      console.error('‚ùå Pas de donn√©es dans la r√©ponse');
      throw new Error('Pas de donn√©es dans la r√©ponse');
    }

    const { token, user } = response.data;
    
    if (!token) {
      console.error('‚ùå Pas de token dans la r√©ponse');
      throw new Error('Pas de token dans la r√©ponse');
    }

    console.log('‚úÖ Token re√ßu, stockage...');
    await AsyncStorage.setItem('userToken', token);
    
    if (user) {
      console.log('‚úÖ Donn√©es utilisateur re√ßues:', user);
      await AsyncStorage.setItem('userData', JSON.stringify(user));
      await AsyncStorage.setItem('userId', user.id.toString());
    }

    return {
      success: true,
      data: {
        token: token,
        user: user
      }
    };

  } catch (error) {
    console.error('‚ùå Erreur d√©taill√©e:', {
      message: error.message,
      response: error.response,
      data: error.response?.data
    });

    return {
      success: false,
      error: error.message || '√âchec de la connexion'
    };
  }
};

export const register = async (username, email, password) => {
  try {
    console.log('üîµ Tentative d\'inscription avec:', { 
      username, 
      email,
      passwordLength: password.length 
    });

    // Les donn√©es doivent √™tre envoy√©es en JSON selon le mod√®le UserCreate
    const data = {
      username: username,
      email: email,
      password: password,
      pseudo: username  // Optionnel, on utilise le username par d√©faut
    };

    console.log('üîµ Donn√©es d\'inscription pr√©par√©es:', {
      ...data,
      password: '[MASQU√â]'
    });

    const response = await api.post('/user', data);

    console.log('‚úÖ R√©ponse d\'inscription:', {
      status: response.status,
      data: response.data
    });

    if (response.data) {
      console.log('‚úÖ Inscription r√©ussie, tentative de connexion automatique...');
      try {
        const loginResponse = await login(username, password);
        console.log('‚úÖ Connexion automatique r√©ussie:', loginResponse.data);
        return response;
      } catch (loginError) {
        console.error('‚ö†Ô∏è √âchec de la connexion automatique:', loginError);
        // On continue m√™me si la connexion automatique √©choue
        return response;
      }
    }

    return response;
  } catch (error) {
    if (error.response) {
      const errorData = error.response.data;
      console.error('‚ùå Erreur serveur:', {
        status: error.response.status,
        data: errorData
      });

      // Gestion des erreurs sp√©cifiques
      if (error.response.status === 400) {
        if (errorData.detail === "User already exists") {
          throw new Error('Un utilisateur avec ce nom ou cet email existe d√©j√†');
        }
      }
      
      throw new Error(errorData.detail || '√âchec de l\'inscription');
    }
    console.error('‚ùå Erreur r√©seau:', error);
    throw new Error('Erreur de connexion au serveur');
  }
};

export const updateProfile = async (userId, data) => {
  try {
    console.log('üîµ Tentative de mise √† jour du profil:', { 
      userId, 
      ...data,
      password: '[MASQU√â]'
    });

    // Les donn√©es doivent √™tre envoy√©es en JSON selon le mod√®le UserCreate
    const userUpdate = {
      username: data.username,
      email: data.email,
      password: data.password,
      pseudo: data.pseudo || data.username
    };

    const response = await api.put(`/user/${userId}`, userUpdate);
    console.log('‚úÖ R√©ponse de mise √† jour:', {
      status: response.status,
      data: response.data
    });

    // Apr√®s la mise √† jour r√©ussie, on se reconnecte pour obtenir un nouveau token
    if (response.data && response.data.data) {
      console.log('‚úÖ Mise √† jour r√©ussie, obtention d\'un nouveau token...');
      try {
        const loginResponse = await login(data.username, data.password);
        console.log('‚úÖ Nouveau token obtenu');
        return response.data;
      } catch (loginError) {
        console.error('‚ö†Ô∏è Erreur lors de l\'obtention du nouveau token:', loginError);
        throw loginError;
      }
    }

    return response.data;
  } catch (error) {
    console.error('‚ùå Erreur de mise √† jour du profil:', {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status
    });
    throw error;
  }
};

export const getVideos = async () => {
  try {
    console.log('üîµ R√©cup√©ration des vid√©os...');
    const response = await api.get('/videos');
    console.log('‚úÖ R√©ponse des vid√©os:', response.data);
    
    // Retourner directement les donn√©es de la r√©ponse
    return response.data;
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des vid√©os:', {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status,
    });
    throw new Error('Impossible de r√©cup√©rer les vid√©os');
  }
};

export const getUserVideos = async (userId) => {
  try {
    console.log('üîµ R√©cup√©ration des vid√©os de l\'utilisateur:', userId);
    const response = await api.get(`/user/${userId}/videos`);
    console.log('‚úÖ R√©ponse des vid√©os utilisateur:', response.data);
    
    // Retourner directement les donn√©es de la r√©ponse
    return response.data;
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des vid√©os utilisateur:', {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status,
    });
    throw new Error('Impossible de r√©cup√©rer les vid√©os de l\'utilisateur');
  }
};

export const uploadVideo = async (userId, name, file) => {
  try {
    console.log('Starting video upload:', { 
      userId, 
      name, 
      file: {
        name: file.name,
        type: file.type,
        size: file.size
      }
    });
    
    // V√©rifier le token avant l'upload
    const token = await AsyncStorage.getItem('userToken');
    console.log('Token before upload:', token);
    
    const formData = new FormData();
    formData.append('name', name);
    formData.append('file', file);

    console.log('FormData created, sending request...');

    const response = await api.post(`/user/${userId}/video`, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
        Authorization: `Bearer ${token}`, // Ajouter explicitement le token
      },
      transformRequest: [(data) => data],
    });
    
    console.log('Upload response:', response.data);

    // D√©clencher l'encodage apr√®s l'upload r√©ussi avec un timeout plus long
    if (response.data && response.data.id) {
      try {
        console.log('Starting video encoding...');
        const encodeResponse = await api.post(
          `/video/${response.data.id}/encode`,
          null,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
            timeout: 300000, // 5 minutes de timeout pour l'encodage
          }
        );
        console.log('Encoding started:', encodeResponse.data);
      } catch (encodeError) {
        console.error('Error starting encoding:', encodeError);
        // On ne relance pas l'erreur car l'upload a r√©ussi
      }
    }

    return response;
  } catch (error) {
    console.error('Upload Video API error:', {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status,
      config: {
        url: error.config?.url,
        method: error.config?.method,
        headers: error.config?.headers
      }
    });
    throw error;
  }
};

export const updateVideo = async (videoId, data) => {
  try {
    const response = await api.put(`/video/${videoId}`, data);
    return response;
  } catch (error) {
    console.error('Update Video API error:', error);
    throw error;
  }
};

export const deleteVideo = async (videoId) => {
  try {
    const response = await api.delete(`/video/${videoId}`);
    return response;
  } catch (error) {
    console.error('Delete Video API error:', error);
    throw error;
  }
};

export const getVideoComments = async (videoId) => {
  try {
    const response = await api.get(`/video/${videoId}/comments`);
    return response;
  } catch (error) {
    console.error('Get Video Comments API error:', error);
    throw error;
  }
};

export const addComment = async (videoId, body) => {
  try {
    const response = await api.post(`/video/${videoId}/comment`, { body });
    return response;
  } catch (error) {
    console.error('Add Comment API error:', error);
    throw error;
  }
};

export const searchVideos = async (params) => {
  try {
    const response = await api.get('/search', { params });
    return response.data;
  } catch (error) {
    console.error('Search API error:', error);
    throw error;
  }
};

export default api;
